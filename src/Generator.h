#ifndef CC_MAP_GEN_H
#define CC_MAP_GEN_H
#include "ExtMath.h"
#include "Vectors.h"
#include "PackedCol.h"
CC_BEGIN_HEADER

/* Implements flatgrass map generator, and original classic vanilla map generation (with perlin noise)
   Based on: https://github.com/ClassiCube/ClassiCube/wiki/Minecraft-Classic-map-generation-algorithm
   Thanks to Jerralish for originally reverse engineering classic's algorithm, then preparing a high level overview of the algorithm.
   Copyright 2014-2025 ClassiCube | Licensed under BSD-3
*/

/* Progress between 0 and 1 for the current step */
extern volatile float Gen_CurrentProgress;
/* Name of the current step being performed */
extern volatile const char* Gen_CurrentState;
extern BlockRaw* Gen_Blocks;

struct MapGenerator {
	cc_bool (*Prepare)(int seed);
	void   (*Generate)(void);
	void   (*Setup)(void); /* Called after World_SetNewMap to configure environment, may be NULL */
};

extern const struct MapGenerator FlatgrassGen;
extern const struct MapGenerator NotchyGen;
extern const struct MapGenerator FloatingGen;
extern const struct MapGenerator CavesGen;
extern const struct MapGenerator EmptyGen;

/* Starts generating a map using the given generator */
void Gen_Start(STRING_REF const struct MapGenerator* gen, int seed,
				int width, int height, int length);
/* The currently active map generator (valid during and after generation) */
extern const struct MapGenerator* gen_active;
/* If Y >= 0, overrides the default spawn position after generation */
extern Vec3 Gen_SpawnOverride;

/* World theme applied during/after generation */
#define GEN_THEME_NORMAL   0
#define GEN_THEME_HELL     1
#define GEN_THEME_PARADISE 2
#define GEN_THEME_WOODS    3
#define GEN_THEME_DESERT   4
#define GEN_THEME_WINTER   5
#define GEN_THEME_MOON     6
#define GEN_THEME_JUNGLE   7
#define GEN_THEME_COUNT    8
extern int Gen_Theme;

/* Centralized theme properties for world generation */
struct GenThemeData {
	/* Terrain blocks */
	BlockRaw surfaceBlock;    /* grass / sand / dirt */
	BlockRaw fillBlock;       /* dirt / sand */
	BlockRaw fluidBlock;      /* still_water / still_lava (internal flood fill) */
	BlockRaw edgeFluidBlock;  /* still_water / still_lava / ice (border flood) */

	/* Edge/sides overrides (0 = let generator decide its own default) */
	BlockRaw edgeBlock;       /* hell=lava, else 0 */
	BlockRaw sidesBlock;      /* hell=obsidian, else 0 */

	/* Cave-specific blocks */
	BlockRaw caveFillBlock;   /* stone / dirt */
	BlockRaw gardenSurface;   /* grass / sand */
	BlockRaw gardenFill;      /* dirt / sand */

	/* Environment colors (0 = keep engine defaults) */
	PackedCol skyCol;
	PackedCol fogCol;
	PackedCol cloudsCol;
	PackedCol shadowCol;

	/* Generation multipliers */
	float heightScale;        /* 1.0 normal, 0.5 paradise/desert */
	int   treePatchMul;       /* 1 normal, 8 woods */
	int   flowerPatchMul;     /* 1 normal, 3 paradise */

	/* Feature flags */
	cc_bool hasShadowCeiling;
	cc_bool hasSnowLayer;
	cc_bool dirtToGrass;       /* dirt physics converts to grass when lit */
	cc_bool hasCaveGardens;
	cc_bool plantsCacti;       /* plant cacti instead of trees */
	cc_bool generateFlowers;
	cc_bool hasExtraCaveOres;  /* cobble + mossy in hell caves */
	cc_bool treesOnDirt;       /* trees can grow on dirt (hell) */
	cc_bool raiseWaterLevel;   /* raise water by Height/8 (paradise) */
	cc_bool hasOases;          /* generate oasis patches (desert) */
	cc_bool hasJungleTrees;    /* generate large 2x2 trunk jungle trees */

	/* Status messages */
	const char* treePlantMsg;
	const char* edgeFloodMsg;
	const char* internalFloodMsg;
};

extern const struct GenThemeData Gen_Themes[GEN_THEME_COUNT];
/* Applies theme-specific environment colors and edge/sides blocks */
void GenTheme_ApplyEnvironment(void);

/* Checks whether the map generator has completed yet */
cc_bool Gen_IsDone(void);


extern BlockRaw* Tree_Blocks;
extern RNGState* Tree_Rnd;
/* Appropriate buffer size to hold positions and blocks generated by the tree generator. */
#define TREE_MAX_COUNT 96
/* Buffer size for jungle trees (2x2 trunk, 18-28 tall, large canopies) */
#define JUNGLE_TREE_MAX_COUNT 800

/* Whether a tree can actually be generated at the given coordinates. */
cc_bool TreeGen_CanGrow(int treeX, int treeY, int treeZ, int treeHeight);
/* Generates the blocks (and their positions in the world) that actually make up a tree. */
/* Returns the number of blocks generated, which will be <= TREE_MAX_COUNT */
int  TreeGen_Grow(int treeX, int treeY, int treeZ, int height, IVec3* coords, BlockRaw* blocks);

/* Whether a jungle tree (2x2 trunk) can be generated at the given coordinates. */
cc_bool JungleTreeGen_CanGrow(int treeX, int treeY, int treeZ, int treeHeight);
/* Generates a jungle tree with 2x2 trunk, large top canopy, and smaller sub-canopies. */
/* Returns the number of blocks generated, which will be <= JUNGLE_TREE_MAX_COUNT */
int  JungleTreeGen_Grow(int treeX, int treeY, int treeZ, int height, IVec3* coords, BlockRaw* blocks);

CC_END_HEADER
#endif
